<html xmlns:svg="http://www.w3.org/2000/svg">

<head>
  <!-- 
    The 'lightWeight' attribute below is important for two reasons:
    * It vastly improves performance
    * There is a bug that Behaviors are not cached correctly, so without
      this property the same HTC file will get called for every SVG element
      on the page. The lightWeight property sidesteps this bug.
  -->
  <public:component lightWeight="true">

      <!-- 
        Grab the SVG inside of an SVG root element and
        process it by the Flash viewer.
      -->
      <public:method name="processSVG" />
      
      <public:method name="setAttribute" />
      <public:method name="getAttribute" />
      <public:method name="addEventListener" />
      
      <public:method name="setAttached" />
      <public:method name="getListeners" />
      
      <public:property name="attached" value="false" internalname="_attached" />
      <public:property name="listeners" internalname="_listeners" />
      <public:property name="libraryPath" value="./" />
       
      <public:attach event="oncontentready" onevent="contentReady()" />
      <public:attach event="onpropertychange" onevent="propertyChange()" />
      
      <public:defaults tabStop="false" contentEditable="false"
                        canHaveHTML="true" viewInheritStyle="true"
                        viewMasterTab="false" viewLinkContent="false"
                        style="display: block" />

  </public:component>

  <script type="text/javascript">
      /** Get the Flash object that is embedding the SVG viewer. */
      function getViewer() {
        //console.log('getViewer');
        
        // we need to get the doc object; we
        // might already have this if we are the root node. However,
        // if we are a child SVG node then we will need to get it, 
        // then cache it to use over and over
        if (typeof this.doc == 'undefined') { // not root node
          // loop until we get our root SVG node
          var root = element.parentNode;
          while (root) {
            if (root.nodeName.toUpperCase() == 'SVG') {
              break;
            }
            
            root = root.parentNode;
          }
            
          if (!root) {
            throw new Error('Unable to find root SVG node');
          }
          
          this.doc = root.doc;
        }
        
        if (typeof this._flashElement == 'undefined') {
          this._flashElement = this.doc.getElementsByTagName('object')[0];
        }
        
        return this._flashElement;
      }

      /** Watch to see when anyone changes a 'style' property so we
          can mirror it in the Flash control. Not implemented
          yet. */
      function propertyChange() {
        //console.log('onpropertychange');
        // TODO: Implement
        var prop = window.event.propertyName;
        if (prop && /^style\./.test(prop)) {
          var styleName = prop.match(/^style\.(.*)$/)[1];
          //console.log(prop + ' changed to ' + this.style[styleName]);
        }
      }
    
      /** Called when the content is ready for some SVG tag in the HTML
          page. This method is called for each individual SVG tag. */
      function contentReady() {
        // We are a dynamically created DOM node and are now live
        if (!this.isAttached() && ownerDocument.readyState == 'complete') {
          this._attached = true;
          // Now that this DOM node is live, pass its contents down into
          // the Flash viewer (but don't do this if we are working with
          // an SVG root node since there's nothing to display yet)
          if (this.nodeName.toUpperCase() != 'SVG') {
            this.processSVG();
            return;
          }
        }
        
        // only insert Flash for the root SVG node
        if (this.nodeName.toUpperCase() != 'SVG') {
          return;
        }
        
        console.log('HTC contentReady');
        
        // get the path to our library resources that we set in the
        // svg.js FlashSVG constructor
        this.libraryPath = window.__svg__libraryPath;

        // generate a random ID for ourselves if we don't have one
        if (!this.id) {
          this.id = this.generateID('__svg__', null);
        }
      
        // get the desired width and height for this element
        var width = this.width;
        var height = this.height;
        
        if (width == undefined || height == undefined) {
          var msg = "Width and height must be defined on the SVG root node";
          console.log(msg);
          throw msg;
        }
        
        if (/px\s*$/.test(width)) {
          width = new Number(width.match(/^\s*(\d+)px\s*$/)[1]);
        }
        
        if (/px\s*$/.test(height)) {
          height = new Number(height.match(/^\s*(\d+)px\s*$/)[1]);
        }
        
        console.log('width='+width);
        console.log('height='+height);
        
        var transparent = '';
        var bgcolor = '';
        if (this.currentStyle.backgroundColor == 'transparent') {
          // no background color specified
          transparent = ' wmode="transparent" ';
        } else {
          bgcolor = ' bgcolor="' + this.currentStyle.backgroundColor + '"';
        }
        
        var flashVars = '"'
            + 'uniqueId=' + this.id
            + '&sourceType=string'
            + '&scaleMode=showAll_svg' // FIXME: is this the right scaleMode?
            + '&debug=true';
        if (typeof(element.id) != "undefined") {
            flashVars = flashVars  + '&svgId=' + this.id;
        }
        flashVars = flashVars  + '"';
        
        // IE is extremely sensitive to how we embed the Flash control into
        // the page; if we do it the wrong way, it will either fail to display
        // or aspects of ExternalInterface will not work. Don't change the
        // code below without extensive testing. Some notes on the approach:
        // * I found that building up the object programmatically (i.e. using DOM
        //  methods) does not work; I had to do it as a giant HTML string
        // * We have to use a DIV container; since we don't want this DIV to
        // stay around, acting almost like a DocumentFragment, we use
        // div.outerHTML on it to have the Flash control go into it and have the
        // DIV 'disappear' in a poof of smoke
      
        // Adapted from Dojo Flash
        var objectHTML =
          '<object classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" '
            + 'codebase="'
            + window.location.protocol /* important for https pages to work */
            + '//fpdownload.macromedia.com/pub/shockwave/cabs/flash/'
            + 'swflash.cab"\n '
            + 'width="' + width + '"\n '
            + 'height="' + height + '">\n '
            + '<param name="Movie" value="' + this.libraryPath + 'svg.swf"></param>\n '
            + '<param name="FlashVars" value=' + flashVars + '></param>\n '
            + (transparent ? '<param name="wmode" value="transparent"></param>\n ' : '')
            + '<param name="AllowScriptAccess" value="always"></param>\n '
          + '</object>';
          
        console.log('objectHTML='+objectHTML);

        // We use the Behavior ViewLink trick to 'hide' this shadow content from 
        // the external page, so that we don't see the Flash object in the 
        // external DOM. For more details on ViewLinks: 
        // http://msdn.microsoft.com/en-us/library/ms531428(VS.85).aspx
        // Note, though, that we want to keep almost all of our SVG elements
        // 'lightWeight' (see the lightWeigth attribute on the
        // public:component tag at the top of this file) because
        // non-lightWeight components have performance and caching issues.
        // LightWeight HTC components however can not use View Links or have
        // shadow content.
        // As a trick, we 'convert' ourselves into having a shadow DOM
        // just for the SVG root tag by manually creating an HTML document below,
        // then storing this document in this.doc for later retrieval.
        // For the trick to work we also have to set some public:defaults
        // above at the top of this file.
        // This approach successfully keeps the performance benefits of
        // lightWeight HTCs while being able to have shadow content that
        // doesn't show up in the external DOM.
        var html = element.document.createElement('html');
        var body = element.document.createElement('body');
        var div = element.document.createElement('div');
        body.appendChild(div);
        html.appendChild(body);
        defaults.viewLink = html.document; // ViewLink magic
        this.doc = html.document;
        // outerHTML must be set _after_ DIV is added to DOM for
        // Flash ExternalInterface to work correctly
        div.outerHTML = objectHTML;  
        
        // If we use the Behavior ViewLink trick to 'hide' the Flash object
        // from the external page's DOM, then Flash's ExternalInterface
        // doesn't work correctly. That's ok, we can fix this with some
        // tricks from Dojo Flash. More details on these
        // hidden Flash methods here:
        // http://codinginparadise.org/weblog/2006/02/how-to-speed-up-flash-8s.html
        console.log('viewer='+getViewer().outerHTML);
        getViewer().sendToFlash = getFlashFunction('sendToFlash');
        console.log('next');
        
        // make our visibility hidden until we are done to prevent flashing
        // TODO: Get this working again
        //this.style.visibility = 'hidden';
      }
      
      /** A function that makes it possible to call Flash functions
          exposed through ExternalInterface. We need to do some magic
          to call Flash functions even though we are embedded inside
          of a Microsoft Behavior. This function encapsulates this magic.
          This function actually returns a function which is then suitable
          for calling. */
      function getFlashFunction(method) {
        return function() {
          return eval(this.CallFunction(
            "<invoke name=\"" + method + "\" returntype=\"javascript\">" 
            + __flash__argumentsToXML(arguments, 0) + "</invoke>"));
        }
      }
    
      /** Called when we are ready to process some SVG and pass it into
          the Flash viewer. */
      function processSVG() {
        console.log('processSVG');
        
        // every SVG node needs an ID so we can do registration
        // between our shadow DOM and the one in Flash
        this.addIDs();
      
        // get the SVG markup and clean it up
        var data = this.getSVG();
        //console.log('data='+data);

        // now pass our SVG into the Flash viewer to render
        if (this.nodeName.toUpperCase() == 'SVG') {
          var self = this;
          // FIXME: Document and test why need this setTimeout here;
          // I believe I needed it to get around a caching bug in IE but
          // I should have documented it; I probably accidentally left it
          // in during testing
          window.setTimeout(function() {
            self.sendToFlash({type: 'load', 
                              sourceType: 'string',
                              svgString: data});
          }, 1);
        } else {
          console.log('SOMEWHERE WHERE I SHOULDNT BE YET!!!');
          var parentId = this.parentNode.id;
          // TODO: Do an appendChild operation using Rick's Flash backend
          /*this.sendToFlash({type: 'invoke', method: 'appendChild',
                            elementId: this.id,
                            childId: childNode.elementId});*/                            
          viewer.__svg__appendChild(data, parentId);
        }
        
        // clear out the background color so it gets rendered by the Flash SVG
        // viewer instead
        this.style.backgroundColor = '';
        
        // become visible now to prevent flashing
        // TODO: Get this working again
        //this.style.visibility = 'visible';
      }
      
      /** Walks the SVG DOM, adding automatic generated IDs to those
          elements which don't have them. We need IDs on all elements
          in order to be able to 'shadow' values between them and
          the SVG DOM inside the Flash viewer. */
      function addIDs() {
        // every SVG node needs an ID so we can do registration
        // between our shadow DOM and the one in Flash
        var current = element;
        while (current) {
          if (!current.id && current.nodeType == 1) {
            current.id = this.generateID('__svg__', null);
          }

          var next = current.firstChild;
          if (next) {
            current = next;
            continue;
          }

          while (current) {
            if (current != element) {
              next = current.nextSibling;
              if (next) {
                current = next;
                break;
              }
            }

            if (current == element) {
              current = null;
            } else {
              current = current.parentNode;
              if (current.nodeType != 1
                  || current.nodeName.toUpperCase() == 'SVG') {
                current = null;
              }
            }
          }
        }
      }
      
      /** Gets the SVG markup from the page and cleans it up, making it
          ready to pass into the Flash SVG viewer. */
      function getSVG() {
        // get the SVG markup and clean it up
        var data = this.outerHTML;
        
        if (this.nodeName.toUpperCase() == 'SVG') {
          // IE adds <?xml:namespace declaration at the beginning; remove it
          data = data.replace(/<\?xml:namespace[^\>]*\>/, '');
          
          // IE also can add an <?IMPORT declaration sometimes -- get rid of it
          data = data.replace(/<\?import[^>]*\/>/mi, '');
          
          // This can leave a leading newline -- remove it if present
          if (data.charAt(0) == '\n') {
            data = data.substring(1);
          }
          
          // add the SVG namespace declaration onto the root SVG node
          // if it is not there
          var rootStr = data.match(/^(<svg:svg[^>]*>)/im);
          if (rootStr && rootStr.length > 0 
              && rootStr[1].indexOf('xmlns:svg') == -1) {
            data = data.replace(/\<svg:svg /, 
                              '<svg:svg xmlns:svg="http://www.w3.org/2000/svg" ');
          }
        } else {
          // strip off the <?import portion for non-SVG root tags
          data = data.replace(/<\?import[^>]*>/m, '');
          data = data.replace(/^\s*/m, '');
          
          // add namespace declarations to this node
          data = data.replace(new RegExp('^<svg:' + this.nodeName), 
                              '<svg:' + this.nodeName
                              + ' xmlns:svg="http://www.w3.org/2000/svg" '
                              + ' xmlns:xlink="http://www.w3.org/1999/xlink" ');
        }
        
        // if there is an 'id' attribute IE strips out the quotes; replace them
        data = data.replace(/id=([^\'\"][^ >]+)(\s|>)/gim, 'id="$1"$2');
        
        // same thing if there is a 'class' attribute
        data = data.replace(/class=([^\'\"][^ >]+)(\s|>)/gim, 'class="$1"$2');
        
        // IE will capitalize some properties in inline style expressions,
        // such as style='DISPLAY: none;'
        // FIXME: both of these will break if there is an inline encoded quote,
        // such as for the content() CSS style attribute
        data = data.replace(/(style=)(')([^']*)(')/gm, '$1"$3"');
        var styleMatches = data.match(/style="[^"]*"/gm);
        for (var i = 0; styleMatches != null && i < styleMatches.length; i++) {
          var oldMatch = styleMatches[i];
          var newMatch = oldMatch;
          var styleAttrs = newMatch.match(/[A-Z_\-0-9]+\:/gm);
          if (styleAttrs == null) {
            continue;
          }
          for (var j = 0; j < styleAttrs.length; j++) {
            newMatch = newMatch.replace(styleAttrs[j], styleAttrs[j].toLowerCase());
          }
          data = data.replace(oldMatch, newMatch);
        }
        
        // sometimes, an onclick= handler will lose it's quotes if there
        // is an attribute afterwards.
        // Example evil IE mangling: 
        // <svg:g id=modeButton onclick=toggleDistribution(); fill="url(#stopButt)">
        //
        // To Fix (only safe way):
        // Identify nodes with onclicks, get their IDs, grab them from the DOM,
        // get their correct onclick values, and then fill this back in the string
        var onclickNodes = data.match(/(<svg:\w+[^>]+(?=onclick=)[^>]+>)/gm);
        for (var i = 0; onclickNodes != null && i < onclickNodes.length; i++) {
          var markup = onclickNodes[i];
          var onclickID = markup.match(/id="([^\"]*)"/)[1];
          var onclickNode = element.ownerDocument.getElementById(onclickID);
          var onclickCode = onclickNode.onclick.toString()
          // IE wraps as anonymous function -- strip
          onclickCode = onclickCode.replace(/^function\s*anonymous\(\)\s*\{\s*/gm, '');
          onclickCode = onclickCode.replace(/\s*\}\s*$/gm, '');
          // backslash double quotes
          var newCode = onclickCode.replace(/\"/gm, '\\"');
          // now inline the correct new onclick code
          RegExp.multiline = true;
          var newMarkup = markup.replace('onclick='+onclickCode, 
                                          'onclick="' + newCode + '"');
          // now inline the entire changed node
          data = data.replace(markup, newMarkup);
        }
        
        // FIXME: The Flash SVG Viewer doesn't work when you have spaces
        // after style attribute names (fill: red for example); fix this there
        data = data.replace(/: /g, ':');
        data = data.replace(/; /g, ';');
        data = data.replace(/>/g, '>\n');
        
        // IE strips out the final semicolon from style lists
        // FIXME: I think this will break for style properties with just
        // one value
        data = data.replace(/style="([^"]*)"/gm, 'style="$1;"');
        
        // If there is a proprietary 'attached' attribute strip it
        data = data.replace(/\s*_attached="(?:true|false)"\s*/mgi, '');
        
        return data;
      }
      
      /** 
          Generates a random ID, making sure there are no collisions.
      
          @param prefix An optional string to put in front of the random ID
                        number.
          @param postfix An optional string to place after the random ID
                        number.
        */
      function generateID(prefix, postfix) {
        // generate an ID for this element
        if (!postfix) {
          postfix = '';
        }
        
        if (!prefix) {
          prefix = '';
        }
        
        var newID = null;
        // keep generating random IDs until we find one not taken
        while (newID == null || element.ownerDocument.getElementById(newID)) {
          newID = prefix + Math.round(Math.random() * 100000 + 1) + postfix;
        }
        
        return newID;
      }
      
      /** Determines whether this node has been attached to an actual SVG
          DOM yet. Needed to differentiate usecases like the following:
          
          var node = document.createElementNS(svgns, 'rect');
          // node is not attached to the Flash viewer yet
          node.setAttribute('fill', 'red');
          var svgRoot = document.getElementsByTagNameNS(svgns, 'svg')[0];
          svgRoot.appendChild(node); // now we are attached
        
          Before we are attached we have to queue up any changes, since we
          can't pass them into the Flash SVG viewer yet until we are
          attached to a node that is actually present in the viewer.
        */
      function isAttached() {
        // HTC 'Properties' are initially returned as strings, even
        // if they are boolean
        return this._attached == 'true' || this._attached == true ? true : false;
      }
      
      /** Makes it possible to indicate whether a node is now attached
          or not (see isAttached() for details on what it means to be attached).
          
          @param attach:Boolean - whether we are now attached
          @param recursive:Boolean - used internally do recursion to
          set all child nodes to the same attached state.
        */
      function setAttached(attach, recursive) {
        // we use a method (setAttached) to set this property
        // rather than use a public:property setter so that we
        // can have a second argument, 'recursive'.
        
        if (typeof recursive == "undefined") {
          recursive = false;
        }
        
        if (!recursive) {
          this._attached = attach;
          return;
        }
        
        // set ourselves and all our children as being attached 
        var current = element;
        while (current) {
          if (current.nodeType == 1) {
            current.setAttached(attach, false);
          }

          var next = current.firstChild;
          if (next) {
            current = next;
            continue;
          }

          while (current) {
            if (current != element) {
              next = current.nextSibling;
              if (next) {
                current = next;
                break;
              }
            }

            if (current == element) {
              current = null;
            } else {
              current = current.parentNode;
              if (current.nodeName.toUpperCase() == 'SVG') {
                current = null;
              }
            }
          }
        }
      }
      
      /** Get any listeners for some event type, such as SVGLoad. */
      function getListeners(type) {
        if (!this._eventHandlers) {
          return [];
        } else if (!this._eventHandlers[type]) {
          return [];
        } else {
          return this._eventHandlers[type];
        }
      }
      
      /** Send a message to the Flash viewer.
          TODO: document the flashMsg payload format. */
      function sendToFlash(flashMsg) {
        flashMsg.uniqueId = element.id;
        try {
          return getViewer().sendToFlash(flashMsg);
        }
        catch(e) {
          return null;
        }
      }
      
      // override some DOM methods to have our own behavior
      
      function getAttribute(attr) {
        console.log('getAttribute, attr='+attr);
        if (this.isAttached()) {
          var result = this.sendToFlash({type: 'invoke', 
                                        method: 'getAttribute',
                                        elementId: element.id,
                                        attrName: attr});
          return (!result) ? null : result.attrValue;
        } else {
          return this[attr];
        }
      }
    
      function setAttribute(attrName, attrValue) {
        console.log('setAttribute, attrName='+attrName);    
        if (this.isAttached()) {
          this.sendToFlash({type: 'invoke', method: 'setAttribute',
                            elementId: element.id,
                            attrName: attrName, attrValue: attrValue});
        } else {
          this[attrName] = attrValue;
        }
        
        if (attrName == 'id') {
          this.id = attrValue;
        }
        
        // FIXME: Does the setAttribute spec require me to return a value?
      }
      
      function addEventListener(type, listener, capture) {
        if (typeof this._eventHandlers == 'undefined') {
          this._eventHandlers = {};
        }
        
        // TODO: Integrate Rick's keydown handling code below
        /*if (type == 'keydown') {
             svgviewer.addEvent(window.document, type, 
                                (function(myListener) {
                                    return function(myEvent) {
                                        if (!myEvent.preventDefault) {
                                            myEvent.preventDefault=function() { this.returnValue=false;};
                                        }
                                        myListener(myEvent);
                                    }
                                })(listener) );
             return;
         }*/

         if (typeof this._eventHandlers[type] == 'undefined') {
             this._eventHandlers[type] = [listener];
         }
         else {
             this._eventHandlers[type].push(listener);
         }
         
         this.sendToFlash({type: 'invoke', method: 'addEventListener',
                           elementId: element.id,
                           eventType: type});
      }
  </script>
</head>
</html>