<!-- 
The 'lightWeight' attribute below is important for two reasons:
* It vastly improves performance
* There is a bug that Behaviors are not cached correctly, so without
  this property the same HTC file will get called for every SVG element
  on the page. The lightWeight property sidesteps this bug.
-->
<component lightWeight="true">

    <!-- _Node properties -->
    <property name="nodeName" get="_getNodeName" />
    <property name="nodeType" get="_getNodeType" />
    <property name="nodeValue" get="_getNodeValue" 
                               put="_setNodeValue" />
    <property name="localName" get="_getLocalName" />
    <property name="prefix" get="_getPrefix" />
    <property name="namespaceURI" get="_getNamespaceURI" />
    
    <property name="childNodes" get="_getChildNodes" />
    
    <property name="parentNode" get="_getParentNode" />
    <property name="firstChild" get="_getFirstChild" />
    <property name="lastChild" get="_getLastChild" />
    <property name="previousSibling" get="_getPreviousSibling" />
    <property name="nextSibling" get="_getNextSibling" />
    
    <property name="textContent" get="_getTextContent"
                                 put="_setTextContent" />
    <property name="data" get="_getData" put="_setData" />
    <property name="ownerDocument" get="_getOwnerDocument" />

    <!-- Non-standard defacto properties -->
    <property name="innerHTML" 
                     get="_getInnerHTML" put="_setInnerHTML" />
                     
    <!-- _Element properties -->
    <property name="id" get="_getId" put="_setId" />
    
    <!-- SVGSVGElement and SVGUseElement readonly props -->
    <property name="x" get="_getX" />             
    <property name="y" get="_getY" />
    <property name="width" get="_getWidth" />
    <property name="height" get="_getHeight" />
    
    <!-- A flag for someone to query whether a DOM node is one of our
         own fake ones or a real browser native one. Useful for someone
         to 'break' the abstraction if needed. -->
    <property name="fake" value="true"/>
             
    <method name="setAttribute" />
    <method name="setAttributeNS" />
    <method name="getAttribute" />
    <method name="appendChild" />
    <method name="removeChild" />
    <method name="replaceChild" />
    <method name="insertBefore" />
    <method name="hasChildNodes" />
    <method name="hasAttributes" />
    <method name="isSupported" />

    <attach event="oncontentready" onevent="contentReady()" />
    <attach event="onpropertychange" onevent="propertyChange()" />
    
    <defaults tabStop="false" contentEditable="false"
                      canHaveHTML="true" viewInheritStyle="true"
                      viewMasterTab="false" viewLinkContent="false"
                      style="display: block" />

</component>

<script type="text/javascript">
  /** Called when the content is ready for some SVG tag in the HTML
      page. This method is called for each individual SVG tag. */
  function contentReady() {
    /*if (this._fakeNode) {
      console.log('contentReady, nodeName='+this._fakeNode.nodeName);
    } else {
      console.log('contentReady');
    }*/
    
    // if we are dealing with an SVG OBJECT, we 'prime the pump' and create
    // a fake tag named svg:__force__load (see _SVGObject._onFlashLoaded()
    // for details). We can't look at our nodeName since that will recursively
    // call our overridden method, so we set a flag when we created the
    // svg:__force__load element
    if (this._realNodeName == '__force__load') {
      // indicate that we are now loaded
      var msg = { type: 'event', 
                  eventType: 'onHTCLoaded',
                  htcNode: this.element };
      this._handler.onMessage(msg);
    } else if (this._fakeNode._attached && this._fakeNode.nodeName == 'svg'
               && this._handler.type == 'script') {
      // This checks to see if we are even really attached. contentReady() will 
      // incorrectly get fired when we create and append the HTC node, even if 
      // it isn't really appended to our actual SVG DOM. Also only fire for SVG 
      // root nodes since we don't really care about this event for other node 
      // types.
      
      // indicate that we are now loaded
      var msg = { type: 'event', 
                  eventType: 'onHTCLoaded',
                  uniqueId: this.id, 
                  elemDoc: element.document,
                  htcNode: this.element };
      this._handler.onMessage(msg);
    }
  }
  
  /** Watch to see when anyone changes a 'style' property so we
      can mirror it in the Flash control. */
  function propertyChange() {
    var prop = window.event.propertyName;
    // svgns property exposed by svg.js not visible here
    var svgns = 'http://www.w3.org/2000/svg';
    
    // called as the page is unloaded and we clean things up, the fakeNode
    // will disappear under us as we remove its reference to prevent
    // memory leaks; detect this and return if so
    if (!this._fakeNode) {
      return;
    }
    
    if (this._fakeNode.nodeType != 1
        || this._fakeNode.namespaceURI != svgns) { // only SVG Element nodes
      return;
    }
    
    // ignore propertychange events for various CSSStyleDeclaration interface
    // methods and properties since those are fired from us setting them 
    // inside of the _Style class
    if (prop == 'style.length' 
        || prop == 'style.item'
        || prop == 'style.setProperty' 
        || prop == 'style.getPropertyValue') {
      return;
    }

    if (!this._fakeNode.style || this._fakeNode.style._ignoreStyleChanges) {
      return;
    }
    
    if (prop && /^style\./.test(prop)) {        
      // extract the style name and value
      var styleName = prop.match(/^style\.(.*)$/)[1];
      var styleValue = this.style[styleName];
      
      // tell our fake node and Flash about style change
      this._fakeNode.style._styleChange(styleName, styleValue);
    }
  }
  
  /** Does some magic to have the Flash object show up in our SVG 
      root element 'hidden' from the external DOM. Called by
      the FlashInserter class inside of svg.js.
      
      @param flash Flash object as HTML string.
      @param size An object literal with two values, width and height,
      with our width and height either in pixels or percentages.
      @param style A style string that we can apply to ourselves
      to have the correct style on the SVG root tag, since that
      is what is visible to the outside DOM. Applying it to the
      Flash object is not enough.
      @param background Object literal with background color and 
      transparent boolean.
      @param className A string of class names to apply to ourselves, null
      if there is none. */
  this._insertFlash = function(flash, size, background, style, className) {
    // apply width and height
    this.style.width = size.width;
    this.style.height = size.height;
    
    // apply our style to ourselves
    var rules = style.split(';');
    for (var i = 0; i < rules.length; i++) {
      var rule = rules[i].split(':');
      if (!rules[i] || rules[i].indexOf(':') == -1) {
        continue;
      }
      var propName = rule[0].replace(/^\s*|\s*$/, '');
      var propValue = rule[1].replace(/^\s*|\s*$/, '');
      this.style[propName] = propValue;
    }
    
    // apply our class name
    if (className) {
      this.className = className;
    }
    
    /**
      Now insert the Flash.
      
      We use a Behavior ViewLink trick to 'hide' this shadow content from 
      the external page, so that we don't see the Flash object in the 
      external DOM. For more details on ViewLinks: 
      
      http://msdn.microsoft.com/en-us/library/ms531428(VS.85).aspx
      
      Note, though, that we want to keep almost all of our SVG elements
      'lightWeight' (see the lightWeight attribute on the
      'component' tag at the top of this file) because
      non-lightWeight components have performance and caching issues.
      LightWeight HTC components however can not use View Links or have
      shadow content.
      
      As a trick, we 'convert' ourselves into having a shadow DOM
      just for the SVG root tag by manually creating an HTML document below,
      then storing this document in this._doc for later retrieval.
      For the trick to work we also have to set some 'defaults'
      above at the top of this file.
      
      This approach successfully keeps the performance benefits of
      lightWeight HTCs while being able to have shadow content that
      doesn't show up in the external DOM.
    */
    var html = element.document.createElement('html');
    var body = element.document.createElement('body');
    var div = element.document.createElement('div');
    body.appendChild(div);
    html.appendChild(body);
    defaults.viewLink = html.document; // ViewLink magic
    this._doc = html.document;
    
    // If we want to allow the background of the Flash movie to be transparent
    // and 'show through' HTML elements underneath, then we need to make our
    // inner shadow document also be transparent; the line below makes this
    // magic happen 
    if (background.transparent) {
      body.style.backgroundColor = 'transparent';
    }
    
    // We have to use a DIV container for the Flash object; since we don't
    // want this DIV to stay around, acting almost like a DocumentFragment,
    // we use div.outerHTML on it to have the Flash control go into it and
    // have the DIV 'disappear' in a poof of smoke
    
    // outerHTML must be set _after_ DIV is added to DOM for
    // Flash ExternalInterface to work correctly
    
    // Note: as _soon_ as we make this call the Flash will load, even
    // before the rest of this method has finished. The Flash can
    // therefore finish loading before anything after the next statement
    // has run, so be careful of timing bugs.
    div.outerHTML = flash;
  }
  
  /** Gets the Flash DOM object. */
  this._getFlashObj = function() {
   var flashObj = this._doc.getElementById(this._handler.flashID);
   
   return flashObj; 
  }
  
  /** Makes calling ExternalInterface functions on the Flash object
      work. */
  this._makeFlashCallable = function(flashObj) {
    // If we use the Behavior ViewLink trick to 'hide' the Flash object
    // from the external page's DOM, then Flash's ExternalInterface
    // doesn't work correctly. That's ok, we can fix this with some
    // tricks from Dojo Flash. More details on these
    // hidden Flash methods here:
    // http://codinginparadise.org/weblog/2006/02/how-to-speed-up-flash-8s.html
    flashObj.sendToFlash = getFlashFunction('sendToFlash');
  }
  
  /** A function that makes it possible to call Flash functions
      exposed through ExternalInterface. We need to do some magic
      to call Flash functions even though we are embedded inside
      of a Microsoft Behavior. This function encapsulates this magic.
      This function actually returns a function which is then suitable
      for calling. */
  function getFlashFunction(method) {
    return function() {
      return eval(this.CallFunction(
        "<invoke name=\"" + method + "\" returntype=\"javascript\">" 
        + __flash__argumentsToXML(arguments, 0) + "</invoke>"));
    }
  }
  
  // there is a very strong correlation between the length of this script
  // and performance, so we minimize size as much as possible
  
  function getAttribute(n) { return this._fakeNode.getAttribute(n); }  
  function setAttribute(n, v) { return this._fakeNode.setAttribute(n, v); }  
  function setAttributeNS(ns, qName, v) { return this._fakeNode.setAttributeNS(ns, qName, v); }
  function appendChild(c) { return this._fakeNode.appendChild(c); }
  function removeChild(c) { return this._fakeNode.removeChild(c); }
  function replaceChild(n, o) { return this._fakeNode.replaceChild(n, o); }
  function insertBefore(n, o) { return this._fakeNode.insertBefore(n, o); }
  function hasChildNodes() { return this._fakeNode.hasChildNodes(); }
  function hasAttributes() { return this._fakeNode.hasAttributes(); }
  function isSupported(f, v) { return this._fakeNode.isSupported(f, v); }

  function _getNodeName() { return this._fakeNode.nodeName; }
  function _getNodeType() { return this._fakeNode.nodeType; }
  function _getLocalName() { return this._fakeNode.localName; }
  function _getPrefix() { return this._fakeNode.prefix; }
  function _getNamespaceURI() { return this._fakeNode.namespaceURI; }
  
  function _getChildNodes() { return this._fakeNode._getChildNodes(); }
  
  function _getParentNode() { return this._fakeNode._getParentNode(); }
  function _getFirstChild() { return this._fakeNode._getFirstChild(); }
  function _getLastChild() { return this._fakeNode._getLastChild(); }
  function _getPreviousSibling() { return this._fakeNode._getPreviousSibling(); }
  function _getNextSibling() { return this._fakeNode._getNextSibling(); }
  
  function _getNodeValue() { return this._fakeNode._nodeValue; }
  function _setNodeValue(v) { return this._fakeNode._setNodeValue(v); }
  
  function _getTextContent() { return this._fakeNode._getTextContent(); }  
  function _setTextContent(v) { return this._fakeNode._setTextContent(v); }
  function _getData() { return this._fakeNode._getData(); }  
  function _setData(v) { return this._fakeNode._setData(v); }
  
  function _getOwnerDocument() { return this._fakeNode.ownerDocument; }
  
  function _getId() { return this._fakeNode._getId(); }
  function _setId(v) { return this._fakeNode._setId(v); }
  
  function _getInnerHTML() { return this._fakeNode._getInnerHTML(); }
  function _setInnerHTML(v) { return this._fakeNode._setInnerHTML(v); }
  
  // SVGSVGElement and SVGUseElement only properties
  
  function _getX() { return this._fakeNode._getX(); }  
  function _getY() { return this._fakeNode._getY(); }  
  function _getWidth() { return this._fakeNode._getWidth(); }
  function _getHeight() { return this._fakeNode._getHeight(); }
</script>

<!-- IE has a bug where if a JScript portion is greater than 512 bytes,
     the page will freeze during unload for a large period of time. 
     There are two workarounds to this:
     
     * Abandon JScript and use VBScript instead, which doesn't have this
       issue.
     * Add an empty script block right after the JScript block that 
       is of type text/vbscript (!!!!)
       
     The bug is documented here:
     
     http://www.pcreview.co.uk/forums/thread-727396.php
     
     This bug and workaround makes me doubt the existence of a higher power
     (or it confirms the existence of a higher power, I'm not sure which).
-->
<script type="text/vbscript"></script>